## zookeeper的特性

```
    a、全局一致性：每个server都保存一份相同的数据，client无论连接那台服务器，都可以得到相同的数据
	b、分布式读写: 更新请求转发，有leader实施更新的写操作
	c、更新请求按顺序读写来自同一份的client的更新请求，会按照顺序执行
	d、数据更新原子性：一次数据要么成功，要么失败
	e、实时性:在一定时间范围内，client读的都是最新的
```

## zookeeper的应用场景

### 数据的发布与订阅

顾名思义就是同步数据，生产者就消息或者配置信息发布在zookeeper上供订阅者去消费

```
应用１：日志的存储，可以将产生的日志放在zookeeper上，供其他消费者去存储	
应用２：业务逻辑上的全局变量，比如消息消息中间键的offset，这样当前zk集群发送者知道发送进度
应用３：集群的节点状态保存，供客户端使用
```

### 分布的通知/协调

ZooKeeper 中特有watcher注册与异步通知机制，能够很好的实现分布式环境下不同系统之间的通知与协调，实现对数据变更的实时处理，采用分布式通知协调更好的降低了不同系统的耦合性。

### 分布式锁

得益于zookeeper的强一致性，任一时刻一个zkServer上的node上的数据一定相同

```
保持独占：通常获取对一个znode操作就只有一个创建这个节点的客户端获取了这个锁
控制时序：当有多个客户端的时候按照时间顺序来获取这个服务
```

#### **实现原理**（重点）

### 集群管理

- 集群机器的监控：如果某节点发生变化，会及时告诉客户端

```
利用ZooKeeper有两个特性，就可以实时另一种集群机器存活性监控系统：
a. 客户端在节点 x 上注册一个Watcher，那么如果 x 的子节点变化了，会通知该客户端。b. 创建EPHEMERAL类型的节点，一旦客户端和服务器的会话结束或过期，那么该节点就会消失
```

- 　master的选举:

  ```
  对于同一业务逻辑，会交给一个节点去完成，其他节点共享这个结果，减少了IO,提高了性能，这也是master集群的好处
  ```

  ### zookeeper的命名服务？

```
在zookeeper的文件系统里创建一个目录，有唯一的目录，可以通过path互相探索发现
这个主要是作为分布式命名服务。通过调用create node api ，能够很容易创建一个全局唯一的path，这个path可以作为一个名称
```

### configuration 配置管理？

```
把这下配置都放在zookeeper上，保存在zooKepeer上的某个目录节点，然后相关应用对这个目录节点进行监听，一旦配置信息发生变化，每个应用程序都会收到ZooKeeeper的通知,然后把最新的析配置信息应用带系统中就好。
```

### zookeeper是怎么保证自身高可用的？



### zookeeper的leader选举机制？

zookeeper提供了三种leader选举机制

- ​	LeaderElection
- ​	AuthFastLeaderElection
- ​	FastLeaderElection

​	默认的的第三种，这里就研究第三种

```
	选举中涉及的概念：
		a、服务器ID：编号越大，在选择算法的中的权重就越大
		b、数据ID：服务器中存放的最大数据ID，服务器状态更新一次就加一次,值越大说明这个数据越新，在选举过程中数据越新，则他权重就越大
		c、逻辑时钟（投票的次数）:同一轮中投票的过程中的逻辑时钟值是相同的。每投完一次逻辑时钟就会增加，然后与其他服务器返回的投票信息中的数据相比，根据不同的值做出不同的判断
		d、选举状态:
			Looking:竞选状态
			Following:随从状态，参与选举
			Observing:观察状态，不参与选举
			Leading:领导者状态
	投票完后会将以下的投票消息发送给所有的服务器
			服务器ID
			数据ID
			逻辑时钟
			选举状态
	××××刚开始启动的时候选举过程：
		1、首先会给自己投一票，逻辑时钟加一次，然后广播投票信息，获取其他服务器的投票信息，
		２、接收来自各个服务器的投票 
		每个服务器都会接收来自其他服务器的投票。集群中的每个服务器在接收到投票后，先判断该投票的有效性，包括检查是否是本轮投票（逻辑时钟）、是否来自LOOKING状态的服务器
		３、处理投票 
		在接收到来自其他服务器的投票后，针对每一个投票，服务器都需要将别人的投票和自己的投票进行PK，PK的规则如下 优先检查ZXID（数据版本）。ZXID比较大的服务器优先作为Leader 如果ZXID相同的话，那么就比较myid。myid比较大的服务器作为Leader服务器，如果投票结果与上一次一样就发送上次结果。
		４、统计投票
			每次投票后，服务器都会统计所有投票，判断是否已经有过半的机器接收到相同的投票信息
			满足（n/2+1)　>２ 
		5、改变服务器状态 
		一旦确定了Leader，每个服务器就会更新自己的状态：如果是Follower,那么就变更为FOLLOWING,如果是Leader，那么就变更为LEADING.
```

